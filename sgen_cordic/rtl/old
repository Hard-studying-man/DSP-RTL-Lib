  
  assign x_init = i_x;
  assign y_init = i_y;
  assign z_init = i_z;
  
  
  generate
    if (gp_mode_rot_vec)
      begin: g_init_rot
        assign d_init = (i_z[gp_z_width-1] == 0) ? 1'b1 : 1'b0;
      end
    else
      begin: g_init_vec
        assign d_init = (i_y[gp_y_width-1] == 1) ? 1'b1 : 1'b0;
      end
  endgenerate
  
  genvar i;
  generate
    for (i=0; i<gp_nr_iter; i=i+1)
      begin: g_cordic_unrolled
        if (i==0)
	  begin: g_cordic_init
	    assign x[i] = (d_init) ? x_init - y_init      : x_init + y_init;
	    assign y[i] = (d_init) ? y_init + x_init      : y_init - x_init;
	    assign z[i] = (d_init) ? z_init - atan_lut[i] : z_init + atan_lut[i];
	  end
	else
	  begin: g_cordic_iter
	    assign x[i] = (z[i][gp_z_width-1==0]) ? x[i-1] - (y[i-1] >>> i) : x[i-1] + (y[i-1] >>> i);
	    assign y[i] = (z[i][gp_z_width-1==0]) ? y[i-1] + (x[i-1] >>> i) : y[i-1] - (x[i-1] >>> i);
	    assign z[i] = (z[i][gp_z_width-1==0]) ? z[i-1] - atan_lut[i]    : z[i-1] + atan_lut[i];
	  end
      end
  endgenerate
